---
title: "Premo 2004 - Reproduced Research"
subtitle: "Local spatial autocorrelation"
author: "Domenico Giusti"
bibliography: "../premo2004_rr.bib"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reading data

```{r}
# read csv
setwd("~/project/premo2004_rr/")
X <- read.csv("data/Premo2004_table1.csv", header=TRUE, sep=",", skip=0)

# convert to SpatialPointDataframe
library(sp)
coo <- X[,c(4,3)]
spX <- SpatialPointsDataFrame(coo, X, proj4string=CRS(as.character(NA)))

coords <- coordinates(spX)
id <- row.names(as(spX, "data.frame"))
```

## 4. Spatial data and methods

```{r}
# table 1
library(knitr)
kable(X)
```

> Table 1 presents the spatial data used in this analysis. Note that it includes the same 47 sites that [@Bove1981], [@Whitley1985], [@Kvamme1990], and [@Williams1993] analyzed. [@Premo2004]

```{r}
# fig.0
library(ggplot2)
ggplot(data=X, aes(x=Easting..km., y=Northing..km., col=Date..AD.)) + geom_point() + coord_fixed(ratio=1) + theme_bw() + xlab("Km East") + ylab("Km North") + ggtitle("Fig.0")
```

### Trend surface analysis

```{r}
# trend surface analysis
```

```{r}
# fig.1
```

> Fig.1. Fourth order trend surface with terminal long-count date locations. Map values are in years AD. Sites are numbered consecutively and identified by name in Table 1. [@Premo2004]

### Spatial autocorrelation

```{r}
# > spdep – sp.correlogram, moran, moran.plot, moran.test, moran.mc. This is the most comprehensive package, and also the most difficult to work with. Does everything, has steep learning curve. (https://www.r-bloggers.com/spatial-correlograms-in-r-a-mini-overview/)
library(spdep)
```

#### Spatial neighbours

> The first step is to define which relationships between observations are to be given a non-zero weight, that is to choose the neighbour criterion to be used [@Bivand2008, p.239]

```{r}
# graph-based neighbours
# > Note that graph-based representations contruct the interpoint relationships based on Euclidean distance, with no option to use Great Circle distances for geographical coordinates. [@Bivand2008, p.244]
library(tripack)
## Delauney triangulation neighbours
X_del <- tri2nb(coords, row.names=id)
X_del <- deldir::deldir(as.data.frame(coords), plotit=TRUE, main="Delauney triangulation neighbours")
## Sphere of Influence neighbours
X_soi <- graph2nb(soi.graph(X_del, coords), row.names=id)
## Gabriel graph neighbours
X_gab <- graph2nb(gabrielneigh(coords), row.names=id)
plot(X$Easting..km., X$Northing..km., xlim=c(0,400), asp=1, main="Gabriel graph neighbours")
plot(X_gab, coords, add=TRUE)
## Relative graph neighbours
X_rel <- graph2nb(relativeneigh(coords), row.names=id)
plot(X$Easting..km., X$Northing..km., xlim=c(0,400), asp=1, main="Relative graph neighbours")
plot(X_rel, coords, add=TRUE)

# distance-based neighbours
# > An alternative method is to choose the k nearest neighbours [...] knearneigh can also take a longlat argument to handle geographical coordinates. [@Bivand2008, p.246]
## k nearest neighbour
X_kn1 <- knn2nb(knearneigh(coords, k=1), row.names=id)
X_kn2 <- knn2nb(knearneigh(coords, k=2), row.names=id)
X_kn4 <- knn2nb(knearneigh(coords, k=4), row.names=id)
## nearest neighbour based on a specified distance
# > The k=1 object is also useful in finding the minimum distance at which all areas have a distance-based neighbour. [@Bivand2008, p.246]
dis <- unlist(nbdists(X_kn1, coords))
summary(dis)
X_kd1 <- dnearneigh(coords, d1=0, d2=1*max(dis), row.names=id)
## nearest neighbour by row distance
X_nb25 <- dnearneigh(coords, d1=0, d2=25, row.names=id)
X_nb50 <- dnearneigh(coords, d1=0, d2=50, row.names=id)
X_nb75 <- dnearneigh(coords, d1=0, d2=75, row.names=id)
### plot
plot(X$Easting..km., X$Northing..km.)
plot(X_nb75, coords, add=TRUE)

# higher-order neighbours
# > Distance bands can be generated by using a sequence of d1 and d2 argument values for the dnearneigh function if needed to construct a spatial autocorrelogram as understood in ecology. In other conventions, correlograms are constructed by taking an input list of neighbours as the first-order sets, and stepping out across the graph to [...] higher-order neighbours [@Bivand2008, p.249]
X_nb_lags <- nblag(X_kn1, maxlag=8)
```

#### Spatial weights

> [...] the second is to assign weights to the identified neighbour links [@Bivand2008, p.239]

> In the same way that the choise of the criteria to define neighbours may affect the results in testing or modelling of the use of weights constructed from those neighbours, results maybe also be changed by the choise of weights style. [@Bivand2008, p.253]

```{r}
# > The nb2listw function takes a neighbours list object and convert it into a weights object. The default conversion style is W, where the weights for each areal entity are standardised to sum to unity [@Bivand2008, p.251]
X_lw_W <- nb2listw(X_nb75, style="W")

# B style (binary)
X_lw_B <- nb2listw(X_nb75, style="B")

# C style
X_lw_C <- nb2listw(X_nb75, style="C")

# U style
X_lw_U <- nb2listw(X_nb75, style="U")

# S style
X_lw_S <- nb2listw(X_nb75, style="S")
```

#### Spatial autocorrelation: global tests

##### Normal and Randomization Inference

```{r}
# global tests
## Moran's I
### > The randomisation option is set to TRUE by default, which implies that in order to get inference based on a normal approximation, it must be explicitly set to FALSE. Similarly, the default is a one-sided test, so that in order to obtain the results for the (more commonly used) two-sided test, the option alternative must be set explicitly to "two.sided". Note also that the zero.policy option is set to FALSE by default, which means that islands result in a missing value code (NA). Setting this option to TRUE will set the spatial lag for islands to the customary zero value. moran.test(spX$Date..AD., listw=nb2listw(X_nb25), zero.policy=TRUE, adjust.n=TRUE) [@Anselin]
I <- moran.test(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))

## Geary's C

## Getis-Ord G
```

##### Permutation Inference

```{r}
# global tests
## Moran's I
set.seed(123456)
I_mc <- moran.mc(spX$Date..AD., listw=nb2listw(X_nb75, style="W"), 99)
I_mc$res
foo <- I_mc$res[1:length(I_mc$res)-1] #remove the last element
bar <- density(foo)
### plot three graphs on top of each other: a (continuous) density function (based on zz), a histogram for the reference distribution, and a line indicating the observed Moran’s I.
plot(bar, ylim=c(0,30), col=2, main="Moran's I permutation test"); hist(foo, freq=TRUE, add=TRUE); abline(v=I_mc$statistic, col=4)
```

##### Correlogram & Plot

```{r}
# correlograms
## Moran's I for lag orders
X_cor8 <- sp.correlogram(neighbours=X_nb25, var=spX$Date..AD., order=8, method="I", style="W")
X_cor3 <- sp.correlogram(neighbours=X_nb25, var=spX$Date..AD., order=3, method="I", style="W", zero.policy = TRUE)
print(X_cor3, p.adjust.methods="holm")
plot(X_cor3)
## Moran's I for distance bands
library(pgirmess)
X_corD <- correlog(coordinates(spX), spX$Date..AD., method="Moran")
print(X_corD)
plot(X_corD)
## Moran's I for regression residuals

X_res <- sp.correlogram(neighbours=X_nb75, residuals())
```

```{r}
# global Moran scatterplot
par(pty="s")
moran.plot(spX$Date..AD., listw=nb2listw(X_nb75, style="W"), labels=as.character(spX$Site.number))

# standardized Moran scatterplot
standard.moran.plot(spX$Date..AD., nb2listw(X_nb75, style="W"))
```

#### Spatial autocorrelation: local tests

> Standardized Ii and Gi variates were calculated for lag distances up to and including 200 km at 25 km intervals (Table 2). [@Premo2004]

```{r}
# local Moran's I
I_loc <- spdep::localmoran(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))
# local Moran's I (two.sided)
I_loc <- spdep::localmoran(spX$Date..AD., listw=nb2listw(X_nb75, style="W"), alternative="two.sided")
# standardized local Moran's I
scale(I_loc[,1])

# local Getis G
G_loc <- spdep::localG(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))
scale(G_loc[,1])
```

## 5. Results

```{r}
spI <- maptools::spCbind(spX, as.data.frame(I))

# ggplot2
ggplot(data=as.data.frame(spI), aes(x=Easting..km., y=Northing..km.)) + geom_point(aes(colour=Ii, size=abs(Ii))) + scale_colour_gradient2(midpoint=0) + scale_radius() + coord_fixed(ratio=1) + theme_bw() + xlab("Km East") + ylab("Km North") + ggtitle("Fig.2")
```

> Fig.2 presents standardized Ii variates at a lag distance of 75 km...

```{r}
# fig.2
## bubble plot
bubble(spI, "Ii", fill=TRUE, col=c("grey","black"), main="Fig.2", xlab="Km East", ylab="Km North")
```

> Fig.3 presents standardized Gi scores at a lag distance of 75 km...

```{r}
# fig.3
```


## References